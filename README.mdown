# netzke-basepack
A pack of basic Rails/ExtJS widgets, as a part of Netzke framework.

# Prerequisites
1. Rails >= 2.2
2. ExtJS >= 2.0: its root *must* be accessible as `RAILS_ROOT/public/extjs`. You may symlink your ExtJS library to here, like this (from your app folder): `cd public && ln -s ~/Developer/extjs/ext-2.2 extjs`
3. `acts_as_list` plugin must be installed: `./script/plugin install git://github.com/rails/acts_as_list.git`

# Installation
Install the gem:
`gem install netzke-basepack`

Include it into environment.rb:
`config.gem "netzke-basepack"`

# Usage
First, run the generators to have the necessary migrations (if not done so already):

`./script/generate netzke_core`

`./script/generate netzke_grid`

Do the migrations:

`rake db:migrate`

This example will provide you with a grid-based scaffold for ActiveRecord-model called `Book`. If you don't have it already, you may generate it like this:

`./script/generate model Book title:string amount:integer`
(don't forget to do the migrations after this)

In the controller declare the widget:

`class WelcomeController < ApplicationController
  netzke_widget :books, :widget_class_name => 'Grid', :data_class_name => 'Book'
end`

After a widget is declared in the controller, it can be accessed in 3 different ways: 1) loaded by means of an automatically created controller action which will produce a basic HTML-page with the widget (handy for testing), 2) embedded directly into a view (by means of helpers), 3) dynamically loaded by other widgets (usually by the widget of class 'Application', if you want a desktop-like, AJAX-driven web-app).

## Using automatically created controller action
Without writing any more code, you can access the widget by `http://yourhost/welcome/books_test`. That is to say, you simply append `_test` to your widget's name (as declared in the controller) and use it as the action of the controller.

## Embedding a widget into a view
netzke-core plugin provides the following 2 helpers to put inside your head-tag (use it in your layout)

1. `netzke_js_include` - to include extjs and netzke javascript files
2. `netzke_css_include` - to include the css. This one can take a parameter to specify a color schema you wish for ExtJS, e.g.: `netzke_css_include(:gray)`

Declaring a widget in the controller provides you with a couple of helpers that can be used in the view:

1. `books_class_definition` will contain the javascript code defining the code for the JS class.
2. `books_widget_instance` will declare a local javascript variable called `book`.

Use these helpers inside of the `<script>`-tag like the following (in the view):
	
`<script type="text/javascript" charset="utf-8">
<%= books_class_definition %>
Ext.onReady(function(){
	<%= books_widget_instance %>
	books.render("books");
})
</script>
<div id="books">the widget will be rendered in this div</div>`

If your layout already calls `yield :javascripts` wrapped in the `<script>`-tag, you can have all javascript-code in one place on the page:

`<% content_for :javascripts do %>
<%= books_class_definition %>
Ext.onReady(function(){
	<%= books_widget_instance %>
	books.render("books");
})
<% end %>
<!-- some HTML... -->
<div id="books">the widget will be rendered in this div</div>`

## Dynamic loading of widgets
TODO: this part will be covered later

# Credentials
Testing done with the help of `http://github.com/pluginaweek/plugin_test_helper`

Copyright (c) 2008 Sergei Kozlov, released under the MIT license
